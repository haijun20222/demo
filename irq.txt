中断机制:
1、中断里为啥不能用睡眠?
   1、首先调用到睡眠函数会调用到schedule函数，会使当前的线程和中断让出cpu。
   2、每一个cpu只有一个中断栈，让出cpu之后，执行其他线程，在线程结束后会调用接口函数，打开本地中断，容易促使中断栈被破坏。
   3、另外一个原因是，由于一个cpu只有一个中断栈，中断程序实在中断栈里执行的，所以调度函数无法调度到中断栈，此时中断就会成为一睡不起。

2、中断上半部分为啥不能被打断?
   1、最主要的原因是中断栈有限，中断嵌套会破坏中断栈。
   2、实时性不高。

3、中断访问临界资源需要注意啥？
    1、中断访问临界资源如果和线程访问的资源一致，加上自旋锁，并关闭本地中断.（原因是在smp 系统中，防止别的cpu产生中断访问资源）
    2、同样在线程中也应该关闭本质中断和加自旋锁irq_spin_save irq_spin_restore 这两个接口，使用这两个接口会更加的安全(保存中断状态，防止之前关闭中断，有关闭中断，结束之后打开中断
4、中断号是在那个文件可以看见？
     硬件中断号：
	 软件中断号 = 硬件中断号+32
	 软中断号：
    cat /proc/interrupts
5、中断分类:
    1、sgi 2、ppi，3、spi
	2、同步中断(内核)，异步中断(硬件)。
	同问：陷入内核几种方式：
	    1系统调用，2、中断，3、异常。
		
6、中断上下部分。
    上半部分：硬件处理程序，中断线程
	下半部分：软中断  tasklet(特殊软中断，不可睡眠)  workqueue(进程上下文，可睡眠)，ksoftirq（中断频繁产生，防止线程饿死）
	
7，什么情况下使用中断上半部分执行。
   1，需要硬件处理
   2、不可打断
   4，时间敏感
   
8、fiq与irq的区别:
   fiq比irq 优先级比较高。
   fiq比irq bank寄存器比较多。
   发生中断切换到不同的模式。
   
9、中断的处理过程。
1，将当前cpsr 保存到spsr
2、保存链接地址lr
2、保存中断现场
3，切换模式
4、执行中断服务函数
5，恢复中断现场

10，linux是如何处理中断的
1、中断初始化，中断映射。
2、中断注册。
3，中断执行。
1、上半部分和下半部分

11、应用层陷入内核层
1、系统调用
2、异常
3，中断


//奔跑
1、发生硬件中断后，ARM64处理器做了哪些事情。
2、硬件中断号与IRQ号如何映射的。
3、一个硬中断发生后，linux内核如何响应和发生中断的。
4、软中断的回调函数执行过程是否允许响应本地中断。
5、同一类型的软中断是否允许多个cpu并行执行。


并发控制:
原子操作为何不可打断:

自旋锁为何要忙等待？

为何多CPU，必须要自旋锁才能互斥？

大锁还是小锁  //互斥的粒度

为何线程有互斥   进程很少听到互斥

所有互斥机制以什么为基础。原子操作。

进程上下文， 中断上下文 有什么差别 ，互斥如何处理	
  
进程 VS 线程


锁得演进关系 //自旋锁 -> 读写锁 -> 顺序锁 -> 读拷贝更新 
           //都基于spinlock  不睡眠 -> 中断，多CPU




学习：
1、中断workqueue
2、rcu

ARM：汇编
arm：体系架构：
工作模式：
1、用户模式：非特权模式，大多数任务运行在此模式下
2、irq模式：低优先级中断产生会进入此模式下
3、fiq模式：高优先级产生会进入此模式下
4、超级管理员模式：当复位和软中断指令会进入此模式下
5、abort：当存取异常会进入此模式下。
6、undef：执行未定义指令会进入此模式下
7、system：使用和usr相同寄存器集的特权模式。

arm有37个寄存器
寄存器：
通用寄存器(30)
pc：程序计数器（1）
cpsr：当前状态寄存器。（1）
spsr：保存状态寄存器（5）
sp：用作堆栈指针。
lr：连接寄存器
mov pc,lr 主要意思是改变pc的值跳到指定汇编位置
汇编指令：
mrs   r0,cpsr  读寄存器的值到r0
msr   cpsr,r0  写寄存器的值到cpsr上面(一般用作切换转台用的)
ldr   load 4四字节：将r7地址空间的数据载入寄存器r0上面
ldrb  载入一字节
ldrh  载入2字节

str r0 [r8]     将r0中的值存储到r8的地址空间中
str r0 [r8],#4  将r0中的值载入r8空间在加四
str r0 [r8,#4]  将r0中的值存到r8+4的空间

stmfd sp!,{r0-r12,lr}      
//将寄存器r0~r12 lr中的值存入栈中   常用于中断保护现场,! 表示会自动偏移                                       
 ldmfd sp!,{r0-r12,pc}^   
//将栈中值逐个弹出到寄存器r0~r12 pc中  常用于中恢复断现场，^表示会恢复spsr到cpsr


线程与进程：
线程与进程的定义：
进程和线程的区别：
进程间的通信：
线程间的互斥与同步：
什么是死锁，死锁的条件，如何避免死锁，如何排查死锁。











