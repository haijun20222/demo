中断机制:
    1、中断里为啥不能用睡眠?
        1、首先调用到睡眠函数会调用到schedule函数，会使当前的线程和中断让出cpu。
        2、每一个cpu只有一个中断栈，让出cpu之后，执行其他线程，在线程结束后会调用接口函数，打开本地中断，容易促使中断栈被破坏。
        3、另外一个原因是，由于一个cpu只有一个中断栈，中断程序实在中断栈里执行的，所以调度函数无法调度到中断栈，此时中断就会成为一睡不起。

    2、中断上半部分为啥不能被打断?
        1、最主要的原因是中断栈有限，中断嵌套会破坏中断栈。
        2、实时性不高。

    3、中断访问临界资源需要注意啥？
        1、中断访问临界资源如果和线程访问的资源一致，加上自旋锁，并关闭本地中断.（原因是在smp 系统中，防止别的cpu产生中断访问资源）
        2、同样在线程中也应该关闭本质中断和加自旋锁irq_spin_save irq_spin_restore 这两个接口，使用这两个接口会更加的安全(保存中断状态，防止之前关闭中断，有关闭中断，结束之后打开中断
    4、中断号是在那个文件可以看见？
        硬件中断号：
        软件中断号 = 硬件中断号+32
        软中断号：
        cat /proc/interrupts
    5、中断分类:
        1、sgi 2、ppi，3、spi
        2、同步中断(内核)，异步中断(硬件)。
        同问：陷入内核几种方式：
            1系统调用，2、中断，3、异常。
    6、中断上下部分。
        上半部分：硬件处理程序，中断线程
        下半部分：软中断  tasklet(特殊软中断，不可睡眠)  workqueue(进程上下文，可睡眠)，ksoftirq（中断频繁产生，防止线程饿死）
        
    7，什么情况下使用中断上半部分执行。
        1，需要硬件处理
        2、不可打断
        4，时间敏感
    
    8、fiq与irq的区别:
        fiq比irq 优先级比较高。
        fiq比irq bank寄存器比较多。
        发生中断切换到不同的模式。
    
    9、中断的处理过程。
        1，将当前cpsr 保存到spsr
        2、保存链接地址lr
        2、保存中断现场
        3，切换模式
        4、执行中断服务函数
        5，恢复中断现场

    10，linux是如何处理中断的
        1、中断初始化，中断映射。
        2、中断注册。
        3，中断执行。
        1、上半部分和下半部分


    11、应用层陷入内核层
        1、系统调用
        2、异常
        3，中断

    12、中断返回时，执行那个进程。
        被打断的进程。




ARM：汇编
    arm：体系架构：
    工作模式：
        1、用户模式：非特权模式，大多数任务运行在此模式下
        2、irq模式：低优先级中断产生会进入此模式下
        3、fiq模式：高优先级产生会进入此模式下
        4、超级管理员模式：当复位和软中断指令会进入此模式下
        5、abort：当存取异常会进入此模式下。
        6、undef：执行未定义指令会进入此模式下
        7、system：使用和usr相同寄存器集的特权模式。

    arm有37个寄存器
        寄存器：
        通用寄存器(30)
        pc：程序计数器（1）
        cpsr：当前状态寄存器。（1）
        spsr：保存状态寄存器（5）
        sp：用作堆栈指针。
        lr：连接寄存器
        m指令：
        mrs   r0,cpsr  读寄存器的值到r0
        msr   cpsr,r0  写寄存器的值到cpsr上面(一般用作切换转台用的)
        ldr   load 4四字节：将r7地址空间的数据载入寄存器r0上面
        ldrb  载入一字节
        ldrh  载入2字节ov pc,lr 主要意思是改变pc的值跳到指定汇编位置
    汇编指令
        str r0 [r8]     将r0中的值存储到r8的地址空间中
        str r0 [r8],#4  将r0中的值载入r8空间在加四
        str r0 [r8,#4]  将r0中的值存到r8+4的空间

    stmfd sp!,{r0-r12,lr}      
    //将寄存器r0~r12 lr中的值存入栈中   常用于中断保护现场,! 表示会自动偏移                                       
    ldmfd sp!,{r0-r12,pc}^   
    //将栈中值逐个弹出到寄存器r0~r12 pc中  常用于中恢复断现场，^表示会恢复spsr到cpsr

并发与互斥：(原因容易造成竞态，多个线程访问资源容易造成数据错乱)
    线程与进程的定义：
    进程和线程的区别：
    进程：资源分配的最小单位。
    线程：程序执行的最小单位。
    线程比进程：(一般将定义，在讲区别)
    1、通信方便：同一进程的线程共享资源，进程与进程之间不共享资源
    2、切换方便。
    3、线程开销小。
    4、进程有固定的程序入口，但是线程需要依赖进程。
    缺点：
         一个线程死了，导致所在的进程挂掉。
    进程优点：
        安全，一个进程死掉不会影响其他进程
    最大区别：
       线程和进程的区别在于进程拥有独立的资源空间，而线程则共享进程的资源空间。

    进程间的通信：
        1、有名管道。
        2、无名管道(父子进程间通信)。
        3、信号。
        4、信号量。
        5、消息队列。
        6、共享内存。
        7、socket通信。
    什么是僵尸进程，孤儿进程，守护进程。
    1、僵尸进程:子进程死了，父进程没死无人收尸。
    2、父进程死了，子进程没死，由1号init进程收尸。
    3、守护进程：创建线程的时候把父进程杀死，然后由1号进程收养。

    线程间的互斥与同步：
    1、原子操作
    ARM 使用 ldrex 和 strex 指令来保证 add 操作的原子性，指令后缀 ex 表示 exclusive(独占访问)
    ldrex Rt, [Rn] 把Rn寄存器指向内存地址的内容加载到Rt寄存器中
    strex Rd, Rt, [Rn] 把Rt寄存器的值保存到Rn寄存器指向的内存地址中，Rd保存更新的结果。
    strex:并发设置为1，否则设置0；设置1  返回重新操作。
    0表示更新成功，1表示失败
    2、内存屏障
    保证屏障前的数据全部执行。
    防止编译乱序和执行乱序。
    读写屏障，多CPU之间的屏障，主要防止，缓存区没有更新。
    (需要举出例子)
    3、自旋锁（拥有 spinlock 锁的临界区代码必须是原子执行，不能休眠和主动调度）
        4、Ticket-based 的 spinlock 机制是如何实现的？
            基于排队自旋锁。next 表示获取的票号 owner正在用餐票号，
            当两者相等才可以访问资源。
        1、为什么 spinlock 的临界区不能睡眠（不考虑 RT-Linux 的情况）？
            死锁: 1、导致其他线程访问临界资源的时候，一直处于忙等待
                2、导致cpu无法调度,浪费cpu资源。
        2、Linux 内核中经典 spinlock 的实现有什么缺点？
        3、为什么 spinlock 临界区不允许发生抢占？
            preempt_disable()关闭了抢占，因此内核不会主动发生抢占
            不能睡眠是：主要原因是内核禁止抢占。
        5、如果在 spin_lock()和 spin_unlock()的临界区中发生了中断，并且中断处理程序也恰
          巧修改了该临界资源，那么会发生什么后果？该如何避免呢
            1、死锁
            具体：
            于是导致中断处理函数
                进入忙等待状态或者 WFE 睡眠状态。在中断上下文出现忙等待或者睡眠状态是致命的，中
                断处理程序要求“短”和“快”，锁的持有者因为被中断打断而不能尽快释放锁，而中断处
                理程序一直在忙等待锁，从而导致死锁的发生
            可以发生中断，但是中断上下文不能访问自旋锁临界取得内容。
            spin_lock_irqsave  spin_lock_restore
    4、互斥锁
        互斥锁比信号量效率高
        自旋锁和互斥锁的区别：
        1、访问临界资源如果资源被其他线程访问，自旋锁忙等待。互斥锁让出cpu，让其他线程执行。
        所以自旋锁适合短期持有，互斥锁适合长期持有。
        互斥锁用在进程级的。
    6、信号量
       耗时长适合信号量。
    7，读写锁
       读多写少
    8、顺序锁
        重读检测
    9、rcu



























;;;;;无锁化设计
    10、条件变量

    11、中断屏蔽

    什么是死锁，死锁的条件，如何避免死锁，如何排查死锁。
    死锁工具：lockdep，crash


C语言基础:
1、编译过程。
预编译，汇编，编译，链接
2、数组和链表的区别：
3、大小端
    1、小端
    低地址存高字节
    2、大端
    低地址存低字节
    如何检测大小端：
    为什么使用大小端：
4、内存分布
1、堆区、栈区，bss，数据断，代码区




//奔跑
1、发生硬件中断后，ARM64处理器做了哪些事情。

2、硬件中断号与IRQ号如何映射的。

3、一个硬中断发生后，linux内核如何响应和发生中断的。
4、软中断的回调函数执行过程是否允许响应本地中断。
5、同一类型的软中断是否允许多个cpu并行执行。

并发控制:
原子操作为何不可打断:

自旋锁为何要忙等待？

为何多CPU，必须要自旋锁才能互斥？

大锁还是小锁  //互斥的粒度

为何线程有互斥   进程很少听到互斥

所有互斥机制以什么为基础。原子操作。

进程上下文， 中断上下文 有什么差别 ，互斥如何处理	
  
进程 VS 线程

锁得演进关系 //自旋锁 -> 读写锁 -> 顺序锁 -> 读拷贝更新 
           //都基于spinlock  不睡眠 -> 中断，多CPU


五一之前：
//rcu
//死锁
//uboot启动
//内核启动
//整理面试题常见的问题(回家整理)
//研究代码规范
//C语言100题25道笔试题//代码开始周日早上。
//周六早上:学习摄像头。












